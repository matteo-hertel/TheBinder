#include <assert.h>
#include <stdio.h>
#include <string.h>

// this should be run from the build/mono folder
const char *outputFile = "../../core/includes/binder/autogen/astgen.h";
const char *fileHeader =
    "THIS IS AN AUTOGENERATED FILE FROM THE METACOMPILER DO NOT MODIFY!\n";
const char *version = "Metacompiler for \"TheBinder\" language v0.0.1\n";

struct ASTNodeDefinition {
  const char *className;
  const char *members;
  ;
};

const ASTNodeDefinition exprDefinitions[] = {
    {"Binary", "Expr* left,Expr* right, TOKEN_TYPE op"},
    {"Grouping", "Expr* expr, Expr* _padding1, TOKEN_TYPE _padding2"},
    {"Literal", "const char* value,Expr* _padding1, TOKEN_TYPE type"},
    {"Unary", "Expr* right,Expr* _padding1, TOKEN_TYPE op"},
};

const ASTNodeDefinition statementsDefinitions[] = {
    {"Expression", "Expr* expression"},
    {"Print", "Expr* expression"},
};

void writeHeader(FILE *fp) {
  fprintf(fp, "/*\n");
  fprintf(fp, fileHeader);
  fprintf(fp, version);
  fprintf(fp, "*/\n\n");
}

void writeIncludes(FILE *fp) {
  fprintf(fp, "#include \"binder/tokens.h\" \n\n");
}

void WriteASTNode(FILE *fp, const char *baseClass,
                  const ASTNodeDefinition &definition) {
  fprintf(fp, "class ");
  fprintf(fp, definition.className);
  fprintf(fp, " : public ");
  fprintf(fp, baseClass);
  fprintf(fp, "\n{\npublic:\n\t");
  fprintf(fp, definition.className);
  fprintf(fp, "(): %s(){}\n\tvirtual ~", baseClass);
  fprintf(fp, definition.className);
  fprintf(fp, "()=default;\n");

  // this might not be the fastest code but is by far the simpler
  const char *source = definition.members;
  int len = strlen(source);
  for (int i = 0; i < len; ++i) {
    // if we have a space after the comma we skip it
    if (source[i] == ' ') {
      ++i;
    }
    // adding indentation
    fputc('\t', fp);
    // parsing new member
    while (source[i] != ',' && i < len) {
      fputc(source[i], fp);
      ++i;
    }

    // closing new member
    fprintf(fp, ";\n");
  }
  // adding the interface
  // accept function
  fprintf(fp, "\tvoid* accept(Visitor* visitor) override\n"
              "\t{ \n \t\treturn visitor->accept");
  fprintf(fp, definition.className);
  fprintf(fp, "(this);\n\n\t};\n");

  // closing class definition
  fprintf(fp, "};\n\n");
}

void generateFromDefinitions(FILE *fp, const char *baseClass,
                             const ASTNodeDefinition *definitions,
                             const int count) {
  // int count = ;
  for (int i = 0; i < count; ++i) {
    WriteASTNode(fp, baseClass, definitions[i]);
  }
}

void openNamespace(FILE *fp) { fprintf(fp, "namespace binder::autogen{\n\n"); }

void closeNamespace(FILE *fp) {
  fprintf(fp, "\n}// namespace binder::autogen");
}

void generateExpressionBaseClass(FILE *fp) {
  fprintf(fp, "class Expr {\n public:\n\tExpr() = default;\n"
              "\tvirtual ~Expr()=default;\n\t //interface\n"
              "\tvirtual void* accept(Visitor* visitor)=0;\n};\n\n");
}

void forwardDeclareClass(FILE *fp, const char *className) {
  fprintf(fp, "class %s;\n", className);
}

void generateVisitorBaseClass(FILE *fp, const char *className,
                              const ASTNodeDefinition *definitions, int count,
                              const char *paramName) {
  // generate a forward delcare for each class
  // int count = sizeof(exprDefinitions) / sizeof(exprDefinitions[0]);
  for (int i = 0; i < count; ++i) {
    forwardDeclareClass(fp, definitions[i].className);
  }

  // declaring the visitor interface, here the class and constructor destructor
  fprintf(fp,
          "\nclass %s{\n public:\n\t%s() "
          "= default;\n"
          "\tvirtual ~%s()=default;\n\t//interface\n",
          className, className, className);

  // here we loop all the class the visitor needs to be able to accept
  // and generate an accept method for the specific class, we use the
  // specific name to not get too crazy with overload, but probably
  // overload would make the code a bit clearer? not sure
  for (int i = 0; i < count; ++i) {
    fprintf(fp, "\tvirtual void* accept");
    fprintf(fp, exprDefinitions[i].className);
    fprintf(fp, "(");
    fprintf(fp, exprDefinitions[i].className);
    fprintf(fp, "* %s) = 0;\n", paramName);
  }
  // closing the class
  fprintf(fp, "\n};\n");
}

void insertStaticClassSizeCheck(FILE *fp) {
  fprintf(fp, "//This class is only here to trigger compile time checks\nclass "
              "Checks{\n");
  fprintf(fp, "\tpublic:\nstatic void sizeCheck(){\n");
  int count = sizeof(exprDefinitions) / sizeof(exprDefinitions[0]);
  for (int i = 0; i < count; ++i) {
    fprintf(fp, "\t\tconstexpr int %sSize = sizeof(%s);\n",
            exprDefinitions[i].className, exprDefinitions[i].className);
  }
  for (int i = 1; i < count; ++i) {

    fprintf(fp,
            "\t\tstatic_assert(%sSize == %sSize, \"Size of %s does not match "
            "size of %s, due to memory pools expecting same size, all AST "
            "nodes need to have same size\");\n",
            exprDefinitions[i - 1].className, exprDefinitions[i].className,
            exprDefinitions[i - 1].className, exprDefinitions[i].className);
  }

  fprintf(fp, "}};\n");
}

int main() {

  FILE *fp = fopen(outputFile, "w");
  assert(fp != nullptr);

  // guard , header , namespace
  fprintf(fp, "#pragma once \n");
  writeHeader(fp);
  writeIncludes(fp);
  openNamespace(fp);

  int exprCount = sizeof(exprDefinitions) / sizeof(exprDefinitions[0]);
  int stmtCount =
      sizeof(statementsDefinitions) / sizeof(statementsDefinitions[0]);

  // Visitor
  // forward declare of the expr class needed by visitor
  forwardDeclareClass(fp, "Expr");
  generateVisitorBaseClass(fp, "Visitor", exprDefinitions, exprCount, "expr");
  // expressions base class
  generateExpressionBaseClass(fp);
  // AST nodes
  generateFromDefinitions(fp, "Expr", exprDefinitions, exprCount);
  // Statement classes
  //generateFromDefinitions(fp, "Stmt", statementsDefinitions, stmtCount);

  // compile time check
  insertStaticClassSizeCheck(fp);
  // wrapping up
  closeNamespace(fp);
  fclose(fp);

  return 0;
}
