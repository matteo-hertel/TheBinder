/*
THIS IS AN AUTOGENERATED FILE FROM THE METACOMPILER DO NOT MODIFY!
Metacompiler for "TheBinder" language v0.0.1
*/

#include "binder/tokens.h" 

namespace binder::autogen{

template <typename T> class Expr;

template <typename T> class Binary;
template <typename T> class Grouping;
template <typename T> class Literal;
template <typename T> class Unary;

template< typename T>
class Visitor{
 public:
	Visitor() = default;
	virtual ~Visitor()=default;
	//interface
	virtual T acceptBinary(Binary<T>* expr) = 0;
	virtual T acceptGrouping(Grouping<T>* expr) = 0;
	virtual T acceptLiteral(Literal<T>* expr) = 0;
	virtual T acceptUnary(Unary<T>* expr) = 0;

};
template< typename T>
class Expr {
 public:
	Expr() = default;
	virtual ~Expr()=default;
	 //interface
	T virtual accept(Visitor<T>* visitor)=0;
};

template< typename T>
class Binary : public Expr<T>
{
public:
	Binary():Expr<T>(){}
	virtual ~Binary()=default;
	Expr<T>* left;
	TOKEN_TYPE op;
	Expr<T>* right;
	T accept(Visitor<T>* visitor) override
	{ 
 		return visitor->acceptBinary(this);

	};
};

template< typename T>
class Grouping : public Expr<T>
{
public:
	Grouping():Expr<T>(){}
	virtual ~Grouping()=default;
	Expr<T>* expr;
	T accept(Visitor<T>* visitor) override
	{ 
 		return visitor->acceptGrouping(this);

	};
};

template< typename T>
class Literal : public Expr<T>
{
public:
	Literal():Expr<T>(){}
	virtual ~Literal()=default;
	const char* value;
	T accept(Visitor<T>* visitor) override
	{ 
 		return visitor->acceptLiteral(this);

	};
};

template< typename T>
class Unary : public Expr<T>
{
public:
	Unary():Expr<T>(){}
	virtual ~Unary()=default;
	TOKEN_TYPE op;
	Expr<T>* right;
	T accept(Visitor<T>* visitor) override
	{ 
 		return visitor->acceptUnary(this);

	};
};


}// namespace binder::autogen